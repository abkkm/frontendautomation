https://www.youtube.com/watch?v=q2ynYUkVWnY&list=PLF5kUO89mjNqNzTG8NvQWjqS7EGlDvGUs&index=2

Reactive programming
Keeps main thread free.
Back pressure on data streams.
App more response.

Reactive Rest API vs Traditional Rest API

Building Reactive Rest API

Spring Webflux

Webclient * WebTestClient


Traditional rest api -

databases blocking call - 1 ms
rest sysnchronous and blocking call - 1 ms

api takes 2 ms to serve the client request.

A thread will be assigned to a thread which makes database call or API call

the thread per request When the client requests execute thread pool we need to do horizonatal scaling (increase instances)

no back pressure support when client requests are more.


We can make asyncrouns and non blcking using reactive rest apis.

Reactive programming
data flows as an event driven stream which is known as reactive stream.

reactive stream specification

it is created by netflix and pivotal.

It has 4 interfaces.

* Publisher - subscribe
* Subscriber - onsubscribe, onnext, onerror, oncomplete
* Subscription - request, cancel
* Processor - extends both publishser and Subscriber

Publisher - subscriber

Publichser - emits the data, Consumer consumes the data

1. subsciber()
subsription
request(n)
4orderNext(Data)
4.1 onNext(data)
...
4.n onNext(data)
oncomplete()

Dependencies

dao - publishser
browser - subscriber

When the subsciber cancels the request. It immediately stops the executioin. But in traditionl approach it coninues execution.

REst API - Controller - Service

Funcation Endpoint - Router - Handler

How to write functional Endpoint

return ServerResponse.ok().
                contentType(MediaType.TEXT_EVENT_STREAM) // data send as stream not object

                
                write all CRUD operations in service class
                ----------------------------

requestForData ()
request(n)
onNext(1), onNext(2),....onNext(n)
onComplete()

No more blocking call
They are realease to do other work.

Reactive programmiing
-EVent/message driven
Functional code style
Baclk pressure on data streams.

https://github.com/shabbirdwd53/reactive-programming-tutorial

https://projectreactor.io/

Netty as non blocking server.

Publisher(Database, server,..) - It will send the data.

OnNext method publisher emits the data using Subscription object.

Mono works with one element
Flux works with multiple elements


Spring reactive uess java reactive library.

We can do opertions on the returned data using operators

After error flux will not stream any data.

Map convert one type to another type

flapMap converts from Mono<String> to Mono<List<String>>
concapMap will preserve the order of the elements
flapMapMany - wants to performs operations on mono return flux (Convets mono of objects(string) to flux of objects)
transforms - converts one type to another type
filter data we can use multipe places

defaultIfEmpty - if no data pass the default
switchIfEmpty - gives 

combines different streams

concat - comibens multipe publibers
concat - static
concatwith - with instance

merge - comibens multipe publibers( not in sequential manner) - Not wait for the publisher to complete
merge - static
mergewith - with instance


mergeSequential - Emits teh data in sequential order

upto we saw same type ( result)
--------------

Zip, ZipWith - Works with different types
(result is different)

doOnNext
doOnSubscribe
doOnComplete

------------

1. handle the error
2. Resume on the error

onErrorReturn - Sends the default value.
OnErrorContinue

onErrorMap - Throwable (Maps runtime exp to throwable)

doOnError operators - same as try catch

retry, retry(n) - 

retry - undefinte try
retry - limited try

retryWhen - retry for particul call(db ,api)


backpressure buffer - keeps the data in buffer

Cold stream - same set of data (hhtp call...)
Hot stream - gets the data at a time interval(sports qote, stock quote)

The StepVerifier is central to testing all things reactive. It gives us a way to assert that what we think is going to come next in the publisher is in fact going to come next in the publisher. The StepVerifier provides several variants on the expect* theme. Think of this as the reactive equivalent to Assert*.

Conclusion
doOnNext works only when data is available and doOnSuccess works with or without data.
doOnNext and doOnSuccess should be used for logging and not updating some values as doOnNext or any of the doOn* methods are NOT subscribing to publishers.


fromiterable - fromlist to create flux or mono

after subsbibe the publisher emits the data.

tranform - converts none type to another type(accepts functional interface as input)

if no data to be emitted - defaultIfEmpyt("Default")
if want to different data - switchIfEmpyt()

concat - with static - (11,12,21,22)
contactwith  - with instance  - (executes in sequential order) 

.delayEletments - emits the data in the different time rate.

mergewith  - (11,21,12, 22)
mergesequential  -  (11,12,21,22) -  (executes in sequential order) 

Zip - 11+21, 12+22 (max 8 sources) - returns tuple
Zipwith 

doon operator - sideeffect - actual behavior dont change., dosuccess, doOnComplete,doOnSubscribe,doOnNext,...

error - when error occurs. the publisher stops emitting the data and sends the error data.

there are two ways to handle the exceptions in reactive streams.

onErrorReturn - Send the default value.

OnErrorContinue - drops the error data and contines another data

onErrorMap - Converts exception to a custom exception.
donOnError - same as try cathc

@Data
@AllArgsconstructor
@NoArgcontructor

flapMap - Flattening the object
retry - retry when there is an exception
retry(3) - retry with 3 times after the first attempt.
retrywhen() - 
backoff - retry interval

-----

backpressure : suppose my publisher emits 100 data whicah can not be handled b my subscriber.


backpressuredrop : handles dropped data.

backpressurebuffer : keeps some data on the buffer

Hot stream : only current data

Cold starem : current data + old data

Debug :

Option 1:

Hooks.onOperatorDebug();

Option 2: Add checkpoint

.map()
.checkpoint("Error Checkpoint")

Option 3: 

add 

reactive-tools depen

ReactorDebugAgent.init(); 
ReactorDebugAgent.processExistingClasses();
in main class


-----------------

sink can act as both publisher and subsciber

Stream events(server side events) from backend to frontend

One way communication

mulitple thread emits mulitple items via the sink.

--

Order Service - Spring data JPA

product service - nosql - Spring Data Reactive Mongo

User service - rdbms - R2DBC - reactive driver for relational db
-----

Whenever you use mongodb empbe

BeanUtils - Convert dto to entity


---

For data server.
Here we are using subscribe method.
But in controller we return publisher.

----

Use flatMap when mono within mono

-----

        return this.service.getUserById(id)
                    .map(ResponseEntity::ok) // if user is present
                    .defaultIfEmpty(ResponseEntity.notFound().build()); //if user is not found

                    -----------



    

